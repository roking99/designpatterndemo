#结构型设计模式-外观模式

模式简介

    外观模式为子系统中的一组接口提供一个统一的入口。降低客户类与子系统间的耦合。
    （个人理解就是将零散的或具有同系列功能的接口整合之后对外提供）
    
设计理念
    
    通过引入一个抽象外观类降低客户类与具体实现类的耦合关系，符合“不和陌生人说话（迪米特法则）”

相关角色

    1、外观角色，客户端可以直接调用它的方法，外观角色知道相关的子系统类（具体实现类）的功能和责任；类似一个调度者,将收到
    的请求转发到相应的子系统对象。
    
    2、子系统角色（具体实现类）：可以存在一个或多个子系统角色，可以是一个类，一个子系统，一个功能模块,可以被客户端或外观
    角色直接调用。对于子系统而言，并不知道外观角色的存在，外观角色也只是表现成一个客户端。

优劣分析

    优点：
        1、对客户端而言，代码变得简单，只需要与外观角色打交道。不必再去关系子系统(具体实现类),与客户端关联的对象减少.
       
        2、 客户端与子系统（具体实现类）的耦合度降低，子系统的变化不会直接影响到客户端。调整外观角色即可。
        
        3、一个子系统的变化不会影响其他子系统，子系统的内部变化也不会影响到外观角色。
        
    缺点：
        1、并没有限制客户端调用子系统，即使采用了外观角色，客户端仍可直接调用其子系统。
        
        2、新增子系统时，可能需要外观类，违反开闭原则
        

适用场景

    1、当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。
    
    2、 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。
    
    3、 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之
    间的耦合度
    
demo介绍
    
     将文件解析功能和文件加密功能通过外观模式进行整合。减少客户端代码。
    
结构图
![](/facadepattern/src/main/static/structure.jpg)