#结构型设计模式--装饰模式

模式简介

    一种对象结构型模式，动态地给一个对象增加一些额外的职责,就增加对象功能来说,装饰模式比生成子类实现更为灵活。
    
设计理念

        装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式来给对象动态增加职责，使用对象之间的关联关系取代类
    之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类
    的功能。
    
        装饰模式与桥接模式的比较：桥接模式是为了在两个不同的继承体系中建立起一个连接,可以让客户端更便捷的调用.而装饰模式
    是为了将原有对象的功能进行加强，也可以理解成更灵活的继承模式。针对的是单个对象或单个继承体系.
        
相关角色
    
    1、抽象构件：是具体构件和抽象装饰类共同父类，声明了具体构件共有的业务方法，它的引入可以使客户端以一致的方式透明的处
    理未被装饰和已装饰的的对象。
    
    2、具体构件：抽象构件的的子类，用于定义具体构件对象。实现了抽象构件中声明的抽象方法，可以被装饰类装饰。
    
    3、抽象装饰类：也是抽象构件的子类，用于装饰具体构件，达到给具体构件增加职责/功能的目的。具体装饰的功能在其子类(具体
    装饰类)中体现。在抽象装饰类中维护了一个抽象构件的对象，通过该对象可以调用未装饰时的方法，并通过其子类对其未装饰时的
    方法进行装饰扩展。
    
    4、具体装饰类：抽象装饰类的子类，负责具体装饰。每一个具体装饰类都定义了一些新的行为，可以调用抽象装饰类中定义的方法，
    并可以增加新的方法用以扩充对象的行为（装饰）。
        

优劣分析
    
     优点：
         
         1、扩展一个对象的功能，装饰模式相对继承更为灵活，也不会导致类的数量急剧增加。
         
         2、可以通过动态的方式来扩展一个对象，通过配置文件可以在运行时指定不同的具体装饰类，从而实现不同的行为。
         
         3、可以多次装饰同一个对象，可以创造更多的不同行为的组合，得到更强大功能的对象。
         
         4、具体构建类和具体装饰类可以独立变化，没有互相依赖。可扩展性良好，符合开闭原则。

     缺点：
         
         1、装饰模式会产生很多的小对象。这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不
         同。而不是它们的类或者属性不同，大量的小对象产生势必会占用系统资源有可能产生性能上的影响。（这句话不是很懂）
         
         2、装饰模式比继承更加灵活，也就意味着易于出错，也难于排错。对于后续的系统维护也带来了一定程度的理解困难。
         
适用场景
    
     1、 在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
    
     2、当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装 饰模式。不能采用继承的情况主要有
     两类：
     第一类是系统中存在大量独立的扩展,为支持每一种扩展或者扩展之间的组合将产生大量的子类,使得子类数目呈爆炸性增长;
     第二类是因为类已定义为不能被继承（如Java语言中的final类).

demo介绍

        Sunny软件公司欲开发了一个数据加密模块，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现,同时还提供
    了稍复杂的逆向输出加密，还提供了更为高级 的求模加密。用户先使用最简单的加密算法对字符串进行加密,如果觉得还不够可以对
    加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。试使用装饰模式设计该多重加密系统。
    

结构图    
![](/decoratorpattern/src/main/static/structure.jpg)