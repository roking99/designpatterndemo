##结构型设计模式--代理模式

模式简介
    
        给一个对象设置一个代理或者占位符，由代理对象控制对原对象的访问。代理模式引入了一个新的对象---代理对象。
    
设计理念
        
        代理对象在客户端和目标对象之间起到中介作用，能对客户端屏蔽服务端不想让客户端了解的内容和服务，也可以增加客户端需
    要的额外服务。
    
相关角色
    
    1、抽象主题：
       声明了真实主题和代理主题共同接口，这样在任何可以使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题
    编程。
    
    2、代理主题：
        包含了对真实主题的引用，从而可以在任何时候都可以操作真是主题对象；在代理主题角色中提供一个与真是主题角色相同的接
    口，以便在任何时候都可以替代真是主题；代理主题还可以管理真是主题，在需要的时候新增或删除真是主题对象，并对真是主题对
    象的引用加以约束。通常在代理主题中客户端在调用所引用的真实主题操作之前或之后还需要进行其他操作，而不是单纯的调用真实
    主题中的方法。
    
    3、真实主题
       定义了代理主题的真实对象，在真实主题中才真正完成了业务操作，客户端可以通过代理主题来间接调用真实主题中定义的操作。
        

优劣分析

      优点：
      
          一、共同优点：
              1、协调调用者和被调用者，在一定程度上降低了系统耦合度
              2、客户端针对抽象主题角色编程，增加和更换代理类无需修改源码，符合开闭原则，系统灵活性和可扩展性较好
      
          二、个性化优点：
              1、远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能
              更好的计算机上，提高系统的整体运行效率。
              2、虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。
              3、 缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短
              执行时间。
              4、保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。
       
      缺点：
           
          1、 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。
          2、 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。
        

适用场景

        代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：
        1、当客户端对象需要访问远程主机中的对象时可以使用远程代理。
        2、当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，
        例如一个对象需要很长时间才能完成加载时。
        3、当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通
        过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。
        4、当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。
        5、当需要为一个对象的访问（引用） 提供一些额外的操作时可以使用智能引用代理
demo

   1、 在某应用软件中需要记录业务方法的调用日志，在不修改现有业务类的基础上为每一个
    类提供一个日志记录代理类，在代理类中输出日志，如在业务方法Method()调用之前输
    出“方法Method()被调用，调用时间为2012-11-5 10:10:10”，调用之后如果没有抛异常则
    输出“方法Method()调用成功”，否则输出“方法Method()调用失败”。在代理类中调用真实
    业务类的业务方法，使用代理模式设计该日志记录模块的结构，绘制类图并使用C#语言
    编程模拟实现。
    
    2、某软件公司欲开发一款基于C/S的网络图片查看器，具体功能描述如下：用户只需在图
    片查看器中输入网页URL，程序将自动将该网页所有图片下载到本地，考虑到有些网
    图片比较多，而且某些图片文件比较大，因此将先以图标的方式显示图片，不同类型
    图片使用不同的图标，并且在图标下面标注该图片的文件名，用户单击图标后可查看
    正的图片，界面效果如图15-7所示。试使用虚拟代理模式设计并实现该图片查看器
    
    3、jdk代理demo、cglib代理demo
代理模式结构图
![](/proxypattern/src/main/static/structure.jpg)
顺便理解下jdk动态代理和cglib动态代理：
    
       动态代理相比于静态代理最大的不同在于，动态代理的每一个功能调用都由InvocationHandler(jdk)/MethodInterceptor(cglib)
    来完成，外界对Proxy角色中的每一个方法的调用，Proxy角色都会交给InvocationHandler(jdk)/MethodInterceptor(cglib)来处理，
    而InvocationHandler(jdk)/MethodInterceptor(cglib)则调用具体对象角色的方法。见结构图：
     
    动态代理模式结构图
![](/proxypattern/src/main/static/dynamicstructure.jpg)
    
    1、jdk动态代理：通过接口配合反射实现代理，代理类需要和真实对象实现完全相同的功能，执行如下步骤：
            
            1.   获取 RealSubject上的所有接口列表；
            2.   确定要生成的代理类的类名，默认为：com.sun.proxy.$ProxyXXXX ；
            3.   根据需要实现的接口信息，在代码中动态创建 该Proxy类的字节码；
            4 .  将对应的字节码转换为对应的class 对象；
            5.   创建InvocationHandler 实例handler，用来处理Proxy所有方法调用；
            6.   Proxy 的class对象 以创建的handler对象为参数，实例化一个proxy对象
        
    2、cglib动态代理：通过类继承实现代理，将真实主题作为代理主题的父类，将父类所有可继承的方法进行(非final)代理增强,执行
    如下步骤:
    
            1.   查找A上的所有非final 的public类型的方法定义；
            2.   将这些方法的定义转换成字节码；
            3.   将组成的字节码转换成相应的代理的class对象；
            4.   实现 MethodInterceptor接口，用来处理 对代理类上所有方法的请求（这个接口和JDK动态代理
                  InvocationHandler的功能和角色是一样的）
            
     动态代理好文：http://blog.csdn.net/luanlouis/article/details/24589193
     

