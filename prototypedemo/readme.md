#创建型设计模式--原型模式

模式简介
    
        原型模式,需要创建的对象通过请求原型对象拷贝原型对象本身来实现创建的过程称为原型模式;例如：孙悟空为原型对象，吹毛
    变成的小猴子即为需要创建的对象;即Object中的clone方法。
    
        这里需要注意的是浅克隆和深克隆;
        
        1、浅克隆
            通过浅克隆,克隆出的对象，对象本身和原型对象是不同的引用,但是克隆出的对象和原型对象中的引用属性是引用的同一个
        地址;也就是说克隆对象和原型对象的引用属性值是相同的,且原型对象或克隆对象改变引用属性的值时会影响另一个对象.
        浅克隆容易产生坑啊;
        
        2、深克隆
            深克隆是指原型对象和原型对象中的引用属性实现了可序列化接口（serializable）,通过序列化和反序列化的方式来避免
        原型对象和克隆对象引用属性引用相同的问题;
         
    扩展下序列化和反序列化：
        1、序列化:即将内存中的原对象及其属性拷贝一份写到流的过程;内存中的原对象不变仍然存在内存中;
        2、反序列化：将流中的对象读出来在内存中创建一个全新对象的过程;
        3、序列化和反序列化的操作可以实现深克隆,深克隆是指克隆对象与原型对象是完全不同的两个引用,而且对象中的成员变量也
           是全新的引用;除了类似之外是完全不同的两个对象不会相互影响;

设计理念
    
    通过对原型对象的拷贝（clone），快速完成新对象的创建;

相关角色
    
    1、Prototype(抽象原型类)：声明克隆方法的接口,是所有具体原型类的父类;可以是接口、抽象类甚至具体实现类
    2、ConcretePrototye(具体原型类):实现抽象原型类的clone方法，在clone方法中返回自己的一个克隆对象
    3、Consumer(客户类):让一个原型对象克隆自身而得到一个新的对象;通过直接实例化原型对象或者工厂方法模式等其他方式获得一
       个原型对象,然后通过原型对象的克隆方法获取多个相同的新对象;（新对象的有一个全新的引用位置）;

优劣分析
    
    优点
        1、简化创建对象的过程(克隆即可)
        2、扩展性良好
        3、简化的创建结构
        4、可以通过深克隆保存状态，实现撤销
    
    缺点
        1、克隆方法在原型类内部,对已有类扩展时，需要修改源码，违背开闭原则
        2、深克隆需要实现序列化接口（serializable）,并且编写较为复杂的逻辑(原型对象写到流中；再从流中读出来创建新的对象)

适用场景
    
    1、创建新对象的成本较大，新的对象可以通过原型对象的复制来获得，或者对成员变量稍作修改即可满足使用
    2、对象的变化状态很小，系统需要保存对象的状态,可以配合备忘录模式来实现
    3、避免使用分层次的工厂来创建分层次的对象，通过原型对象得到的新对象比使用构造函数创建新对象更方便

demo介绍

        设计并实现一个客户类Customer，其中包含一个名为客户地址的成员变量，客户地址的类型为Address，用浅克隆和深克隆分别
    实现Customer对象的复制并比较这两种克隆方式的异同。